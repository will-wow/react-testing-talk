import { prism } from "mdx-deck/themes";
import { Flex, Box, Heading, Image } from "@rebass/emotion";
import theme from "./theme";

export const themes = [prism(theme)];

import { Notes, Split, FullScreenCode, Horizontal, Invert } from "mdx-deck";
import BgImage from "./components/BgImage";
import Img from "./components/Img";

import allTheThings from "./assets/all-the-things.jpg";
import cypressDemo from "./assets/cypress.webp";
import jasmineLogo from "./assets/jasmine.png";
import jestLogo from "./assets/jest.png";
import mochaLogo from "./assets/mocha.svg";
import reactUsage from "./assets/react-usage.png";
import reactLogo from "./assets/react.svg";
import kentShallow from "./assets/kent-shallow.png";

# Testing React in 2019

<Img alt="react logo" src={reactLogo} />

## Will Ockelmann-Wagner

wow@carbonfive.com | [github.com/will-wow](http://github.com/will-wow)

<Notes>

Hi, C5
We write a lot of react, and are into testing
How many people here work at a company that writes react?
How many have written a react component?
How many are happy with their testing strategy?

</Notes>

---

# React is Everywhere

<Img alt="react usage" src={reactUsage} />

<Notes>

In the 2019 Stack Overflow survey, React passed Angular for the first time.
But the fact that Angular is still hanging out, and jQuery is still dominant,
means React isn't going away any time soon, there's a long tail for these frameworks.

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

## React Testing is All Over the Place

| Test Runner | Test Framework        | Test Style |
| ----------- | --------------------- | ---------- |
| Jest        | Enzyme                | Shallow    |
| Jasmine     | React Testing Library | Render     |
| Mocha       | react-test-renderer   | Snapshot   |

</div>

<Notes>

_Testing_ React, on the other hand, is a little all over the place right now.

You've got three popular test runners, three testing frameworks, and three main types of test for unit testing. We'll walk through all of these tonight.

</Notes>

---

## Cypress.io: TestableLA Approved

<Img alt="cypress.io" src={cypressDemo} />

<Notes>

As a sidenote, the browser testing landscape is a little clearer.
TestableLA has had a couple talks about Cypress last year, including one from a cypress dev
At this point, if your backend frameworks comes with a browser testing tool, then that's probably the
way to go. But if your frontend is more standalone, then cypress is a really nice choice.

I used it on my last project, and in four months we didn't have a single flaky test failure, which is pretty wild. But this talk is focued on unit testing frameworks, so we can talk more about cypress after,
if anyone is interested.

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

## I used them all... together

| Test Runner | Test Framework            | Test Style   |
| ----------- | ------------------------- | ------------ |
| **Jest**    | **Enzyme**                | **Shallow**  |
| Jasmine     | **React Testing Library** | **Render**   |
| Mocha       | **react-test-renderer**   | **Snapshot** |

</div>

<Notes>

In a recent project, we ended up using all of these in one codebase.
I wouldn't nessecarily reccomend that. Over time we learned that all of these
tools can do all three kinds of test style, so you probably only need one.

Still it means I got the chance to compare and contrast the three and report back to you!

</Notes>

---

<BgImage src={allTheThings} />

<Notes>

So yeah, don't use all the things

</Notes>

---

# Test Runners

<Flex justifyContent="space-between">

<Img src={jasmineLogo} />
<Img src={mochaLogo} />
<Img src={jestLogo} />

</Flex>

<Notes>

How many people have used jasmine, mocha, jest

</Notes>

---

# BDD Expectations

describe/it/should vs. test/assert

<Notes>

All of these test runners either include or support BDD-style expectations, where you use describe, it, and should to write your tests. There's also TDD-style, where you use 'test' and 'assert', but BDD seems to be in vogue right now.

</Notes>

---

```javascript
describe("simple tests", () => {
  it("finds matching objects", () => {
    expect([1, 2, 3]).toEqual([1, 2, 3]);
  });

  it("finds partial string matches", () => {
    expect("Hello World").toContain("World");
  });

  it("finds missing values", () => {
    expect([1, 2, 3]).toEqual([1, 3]);
  });
});
```

<Notes>

Here's what Jest looks like, but all three of these are going to look about the same.
Notice that this isn't react-specific. Jest, Jasmine, and Mocha are all general-purpose
test runners, they can run tests for Node or whatever too.
So how to choose?

</Notes>

---

<Img src={jasmineLogo} sx={{ mb: 3 }} />

- Familiar from AngularJS days
- Runs in a browser with Karma
- Runs headless in node these days
- Still works just fine

---

<Img src={mochaLogo} />

- Popular Node test framework üëç
- Usually paired with Chai for BDD expectations üçµ

---

<Img src={jestLogo} />

- New hotness :star-struck:
- Great Visual Studio Code integration ü§ì
- Comes with change watcher and code coverage üëÄ
- The standard choice for React ‚úÖ

---

<Invert>

# TL;DR: Choose Jest for new projects

# Don't change existing projects

</Invert>

<Notes>

So basically, if you're starting a new project, probably go with Jest.
If you've got an exisitng project, or everybody is used to some other runner, then there's not a big reason to switch.
For the rest of this talk I'll stick with Jest, but this stuff works with any runner.

</Notes>

---

# Test Libraries

<Notes>

Now we can get into the testing libraries, which isn't so easy of a choice. I'll go through them at a high level,
and then we'll dig in to see the differences.

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

# Enzyme

|                |                 |
| -------------- | --------------- |
| Author         | AirBnB          |
| Initial Commit | 8/10/2015       |
| Initial Commit | 17,699          |
| Strengh        | Shallow testing |
| Weakness       | Refactoring     |

</div>

<Notes>

If you've testing a react app in the last few years, you probably used enzyme.
It's mature and well supported, and particularly good for shallow testing, which we'll get into in a bit
But, you'll find that refactoring your code without changing functionality can break enzyme tests

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

# React Testing Library

|                |                      |
| -------------- | -------------------- |
| Author         | Kent Dodds           |
| Initial Commit | 3/19/2018            |
| Github Stars   | 8,211                |
| Strengh        | User-focused testing |
| Weakness       | Isolated tests       |

</div>

<Notes>

Then last year, Kent Dodds came out with RTL, and it's really taken off
It's focused on getting you to write tests from a user perspective.
The idea is that if you refactor the structure or classnames in a component
but it doesn't change from a UX perspective, then the test should still pass
But, it does make it harder to write isolated tests, as we'll see

</Notes>

---

"The more your tests resemble the way your software is used,  
the more confidence they can give you."  
-- Kent Dodds

<Notes>

RTL Guiding priciple

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

# react-test-renderer

|                |                          |
| -------------- | ------------------------ |
| Author         | Facebook                 |
| Initial Commit | :shrug:                  |
| Strengh        | Simplicity, React Native |
| Weakness       | Low level                |

</div>

<Notes>

Finally, React has always come with its own test utils. But this year they
added react-test-renderer, which renders a react component to JSON
They don't rely on a virtual dom, so support react native
particularly good for snapshot tests, but supports some other test types.

</Notes>

---

# Sample app

<iframe
  src="https://todo-react-testing.surge.sh/"
  width="1000"
  height="600"
  style={{ background: "#FFFCF7" }}
/>

<Notes>

As we walk through these choices, I find it's nice to have a concerete example
The traditional todo app, made with react and redux.

- Add, remove done
- When all are done, you get a Inbox Zero message
- That message is configurable

</Notes>

---

```jsx
<Connected(TodoContainer)>
  <TodoList>
    <Connected(UsernameInput) />
    {isAllDone && <Connected(InboxZero) />}
    <TodoItem />
    <TodoItem />
    Done Items
    <TodoItem />
    <TodoItem />
  </TodoList>
</TodoContainer>
```

<Notes>

Here's what more or less the component structure looks like
There's a TodoContainer, which is connected to the redux store
It renders a TodoList component, which renders some todo items

also a Username input and conditionally an InboxZero message, both of which are also connected to redux
We'll see why that's important for testing in a bit

</Notes>

---

# TodoList Props

```jsx
const TODO_LIST = [{id: 1, title: 'Get Milk'}, ...];
const props = {
  todoList: TODO_LIST,
  onTodoChange: jest.fn(),
  onDelete: jest.fn()
};
```

<Notes>

As a note, for all these tests we'll use this same set of props
in React a component takes a set of props to render itself
React functions are functions that take props and return HTML
So if todo list has two items, then the component will render two input boxes
Also, jest.fn is how you make a spy in jest.
A spy is a function that we can make return something if we want
But either way can check if its been called in a test.

TodoList interacts with the redux store, so clicking a button won't directly do anything except call one of these functions
That means...

</Notes>

---

# Most React Tests test two things:

1. Given **props**, does it render the right **elements**?
1. Given an **event**, does it **call** the right functions?

---

# Decisions, decisions...

Shallow vs Full Render

Tradtional Expectations vs Snapshots

<Notes>

There are two decisions you have to make about any component test
Shallow renders one component, full renders children
Traditional expectations are how you normally write tests
Expect x to have prop y
Snapshots take a snapshot of the dom, and fail if it changes
Let's go through them

</Notes>

---

# Shallow Render

```jsx
<TodoList>
  <Connected(UsernameInput) />
  <TodoItem />
  <TodoItem />
  Done Items
  <TodoItem />
  <TodoItem />
</TodoList>
```

<Notes>

In a shallow test, you only render one level deep. So if I shallow-rendered the TodoList component, it renders
its children, which are TodoItem components. But it doesn't go and render those children,
so it doesn't go all the way to the level of buttons and inputs
Makes for good unit testing - TodoList doesn't know how its children render themselves, so arguably its test shouldn't either

</Notes>

---

# Enzyme Shallow

```jsx
import { shallow } from "enzyme";
it("renders all todo items", () => {
  const wrapper = shallow(<TodoList {...props} />);
  expect(wrapper.find("TodoItem")).toHaveLength(TODO_LIST.length);
});
```

<Notes>

Here's how you set up a shallow render in enzyme.
Import shallow, and render the component with some props
Then you have a wrapper that you can traverse and assert on
Check that it has one TodoItem for each list item.

</Notes>

---

```jsx
it("passes props down", () => {
  expect(
    wrapper
      .find("TodoItem")
      .first()
      .prop("todo")
  ).toEqual(TODO_LIST[0]);
});
```

<Notes>

Since we're not rendering the actual inputs, we can't check they they have the right data
All we can do is check that we're passing the right data to the right component.
Then can write another test that checks that, given some todo data, the TodoItem component show it in an input
So nice and isolated

</Notes>

---

# Shallow Downside: Refactoring

<Notes>

I like this approach
One big downside is refactoring - change to the code, but not what it does
a good react dev looks for opportunities to refactor a chunk of html into a component
Shallow makes that harder
look at an example:

</Notes>

---

```jsx
<TodoList>
  Things to do:
  <TodoItem todo={todos[0]}>
  <TodoItem todo={todos[1]}>
  Done:
  <TodoItem todo={todos[2]}>
  <TodoItem todo={todos[3]}>
</TodoList>
```

<Notes>

So here's how this looks now: there's some code that seperates out done todos and puts them under a header
But maybe we want to add a wrapper component, TodoWrapper, that gets a list of either to-do or done items, and renders them
with the right header.
That would look like:

</Notes>

---

# Refactored

```jsx
<TodoList>
  <TodoWrapper done={false} todos={[todos[0], todos[1]]} />
  <TodoWrapper done={true} todos={[todos[2], todos[3]]} />
</TodoList>
```

<Notes>

Seems like a good refactor, but now all the tests are broken, because TodoList isn't rendering TodoItems anymore
So even though from a user perspective the UX is exactly the same, we have to totally rewrite our tests
This might make you decide not to make the right refactor, which is a bummer

</Notes>

---

# react-test-render Shallow 

```jsx
import { createRenderer } from "react-test-renderer/shallow";
const renderer = createRenderer();
renderer.render(<TodoList {...props} />);
const component = renderer.getRenderOutput();
```

<Notes>

also lets you shallow render, but you can't do much except snapshot the
result, which we'll see later.
So less interesting

</Notes>

---

# React Testing Library

<Img src={kentShallow} />

<Notes>

Kent Dodds isn't a fan of shallow testing, so... yeah, no shallow in his library.

</Notes>

---

# Mount Test

```html
<div class="TodoList">
  <div>
    <h2>Todo List for:</h2>
    <input class="UsernameInput" />
  </div>
  <hr />
  <div class="TodoItem">
    <input placeholder="Enter a todo item" value="Learn Enzyme" />
    <button>Done</button>
    <button>X</button>
  </div>
  <div>
    <input placeholder="Enter a todo item" value="Learn RTL" />
    <button>Done</button>
    <button>X</button>
  </div>
</div>
```

<Notes>

Full render renders all the way to the dom, from the component you start with
You can see the TodoList, Username input, and individual TodoItems, which are all components, rendered down to dom
So you can do things like trigger a click on a button that should effect a parent's state

</Notes>

---

```jsx
```

---

- Unit Testing
  - Jest
    - Enzyme Shallow
    - Enzyme Mount
    - Snapshot Testing (w/ Test Renderer): https://reactjs.org/docs/test-renderer.html)
    - React Testing Library
    - Hooks (React.useEffect + spy)
    - --coverage
