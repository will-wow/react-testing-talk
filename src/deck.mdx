import { prism } from "mdx-deck/themes";
import { Flex, Box, Heading } from "@rebass/emotion";
import theme from "./theme";

export const themes = [prism(theme)];

import {
  Notes,
  Split,
  FullScreenCode,
  Horizontal,
  Invert,
  Image
} from "mdx-deck";
import BgImage from "./components/BgImage";
import Img from "./components/Img";

import allTheThings from "./assets/all-the-things.jpg";
import cypressDemo from "./assets/cypress.webp";
import jasmineLogo from "./assets/jasmine.png";
import jestLogo from "./assets/jest.png";
import mochaLogo from "./assets/mocha.svg";
import reactUsage from "./assets/react-usage.png";
import reactLogo from "./assets/react.svg";
import jestCoverage from "./assets/jest-coverage.png";
import jestTerminal from "./assets/jest-terminal.png";
import jestVsCode from "./assets/jest-vscode.png";
import kentShallow from "./assets/kent-shallow.png";
import mountFail from "./assets/mount-fail.png";
import snapshotGood from "./assets/snapshot-good.png";
import snapshotBad from "./assets/snapshot-bad.png";

# Testing React in 2019

<Img alt="react logo" src={reactLogo} />

## Will Ockelmann-Wagner

wow@carbonfive.com | [github.com/will-wow](http://github.com/will-wow)

<Notes>

Hi, C5
We write a lot of react, and are into testing
How many people here work at a company that writes react?
How many have written a react component?
How many are happy with their testing strategy?

</Notes>

---

# React is Everywhere

<Img alt="react usage" src={reactUsage} />

<Notes>

In the 2019 Stack Overflow survey, React passed Angular for the first time.
But the fact that Angular is still hanging out, and jQuery is still dominant,
means React isn't going away any time soon, there's a long tail for these frameworks.

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

## React Testing is All Over the Place

| Test Runner | Test Framework        | Test Style |
| ----------- | --------------------- | ---------- |
| Jest        | Enzyme                | Shallow    |
| Jasmine     | React Testing Library | Render     |
| Mocha       | react-test-renderer   | Snapshot   |

</div>

<Notes>

_Testing_ React, on the other hand, is a little all over the place right now.

You've got three popular test runners, three testing frameworks, and three main types of test for unit testing. We'll walk through all of these tonight.

</Notes>

---

## Cypress.io: TestableLA Approved

<Img alt="cypress.io" src={cypressDemo} />

<Notes>

As a sidenote, the browser testing landscape is a little clearer.
TestableLA has had a couple talks about Cypress last year, including one from a cypress dev
At this point, if your backend frameworks comes with a browser testing tool, then that's probably the
way to go. But if your frontend is more standalone, then cypress is a really nice choice.

I used it on my last project, and in four months we didn't have a single flaky test failure, which is pretty wild. But this talk is focued on unit testing frameworks, so we can talk more about cypress after,
if anyone is interested.

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

## I used them all... together

| Test Runner | Test Framework            | Test Style   |
| ----------- | ------------------------- | ------------ |
| **Jest**    | **Enzyme**                | **Shallow**  |
| Jasmine     | **React Testing Library** | **Render**   |
| Mocha       | **react-test-renderer**   | **Snapshot** |

</div>

<Notes>

In a recent project, we ended up using all of these in one codebase.
I wouldn't nessecarily reccomend that. Over time we learned that all of these
tools can do all three kinds of test style, so you probably only need one.

Still it means I got the chance to compare and contrast the three and report back to you!

</Notes>

---

<BgImage src={allTheThings} />

<Notes>

So yeah, don't use all the things

</Notes>

---

# Test Runners

<Flex justifyContent="space-between">

<Img src={jasmineLogo} />
<Img src={mochaLogo} />
<Img src={jestLogo} />

</Flex>

<Notes>

How many people have used jasmine, mocha, jest

</Notes>

---

# BDD Expectations

describe/it/should vs. test/assert

<Notes>

All of these test runners either include or support BDD-style expectations, where you use describe, it, and should to write your tests. There's also TDD-style, where you use 'test' and 'assert', but BDD seems to be in vogue right now.

</Notes>

---

```javascript
describe("simple tests", () => {
  it("finds matching objects", () => {
    expect([1, 2, 3]).toEqual([1, 2, 3]);
  });

  it("finds partial string matches", () => {
    expect("Hello World").toContain("World");
  });

  it("finds missing values", () => {
    expect([1, 2, 3]).toEqual([1, 3]);
  });
});
```

<Notes>

Here's what Jest looks like, but all three of these are going to look about the same.
Notice that this isn't react-specific. Jest, Jasmine, and Mocha are all general-purpose
test runners, they can run tests for Node or whatever too.
So how to choose?

</Notes>

---

<Img src={jasmineLogo} sx={{ mb: 3 }} />

- Familiar from AngularJS days
- Runs in a browser with Karma
- Runs headless in node these days
- Still works just fine

---

<Img src={mochaLogo} />

- Popular Node test framework üëç
- Usually paired with Chai for BDD expectations üçµ

---

<Img src={jestLogo} />

- New hotness :star-struck:
- Great Visual Studio Code integration ü§ì
- Comes with change watcher and code coverage üëÄ
- The standard choice for React ‚úÖ

---

# Jest: Visual Studio Code integration

<Img src={jestVsCode} />

---

# Jest: Diffing

<Img src={jestTerminal} />

---

# Jest: Code Coverage Built In

<Img src={jestCoverage} />

<Notes>

Finally, jest has code coverage built in
So when Rit asks what your code coverage is, you can answer him right away

</Notes>

---

<Invert>

# TL;DR: Choose Jest for new projects

# Don't re-write existing tests

</Invert>

<Notes>

So basically, if you're starting a new project, probably go with Jest.
If you've got an exisitng project, or everybody is used to some other runner, then there's not a big reason to switch.
For the rest of this talk I'll stick with Jest, but other than snapshots this'll all be the same in any runner.

</Notes>

---

# Test Libraries

<Notes>

Now we can get into the testing libraries, which isn't so easy of a choice. I'll go through them at a high level,
and then we'll dig in to see the differences.

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

# Enzyme

|                |                 |
| -------------- | --------------- |
| Author         | AirBnB          |
| Initial Commit | 8/10/2015       |
| Initial Commit | 17,699          |
| Strengh        | Shallow testing |
| Weakness       | Refactoring     |

</div>

<Notes>

If you've testing a react app in the last few years, you probably used enzyme.
It's mature and well supported, and particularly good for shallow testing, which we'll get into in a bit
But, you'll find that refactoring your code without changing functionality can break enzyme tests

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

# React Testing Library

|                |                      |
| -------------- | -------------------- |
| Author         | Kent Dodds           |
| Initial Commit | 3/19/2018            |
| Github Stars   | 8,211                |
| Strengh        | User-focused testing |
| Weakness       | Isolated tests       |

</div>

<Notes>

Then last year, Kent Dodds came out with RTL, and it's really taken off
It's focused on getting you to write tests from a user perspective.
The idea is that if you refactor the structure or classnames in a component
but it doesn't change from a UX perspective, then the test should still pass
But, it does make it harder to write isolated tests, as we'll see

</Notes>

---

"The more your tests resemble the way your software is used,  
the more confidence they can give you."  
-- Kent Dodds

<Notes>

RTL Guiding priciple

</Notes>

---

<div style={{width: "80%", textAlign: 'center'}}>

# react-test-renderer

|                |                          |
| -------------- | ------------------------ |
| Author         | Facebook                 |
| Initial Commit | 3/28/2019                |
| Strengh        | Simplicity, React Native |
| Weakness       | Low level                |

</div>

<Notes>

Finally, React has always come with its own test utils. But this year they
added react-test-renderer, which renders a react component to JSON
They don't rely on a virtual dom, so support react native
particularly good for snapshot tests, but supports some other test types.

</Notes>

---

# Sample app

<iframe
  src="https://todo-react-testing.surge.sh/"
  width="1000"
  height="600"
  style={{ background: "#FFFCF7" }}
/>

<Notes>

As we walk through these choices, I find it's nice to have a concerete example
The traditional todo app, made with react and redux.

- Add, remove done
- When all are done, you get a Inbox Zero message
- That message is configurable

</Notes>

---

```jsx
<Connected(TodoContainer)>
  <TodoList>
    <Connected(UsernameInput) />
    {isAllDone && <Connected(InboxZero) />}
    <TodoItem />
    <TodoItem />
    Done Items
    <TodoItem />
    <TodoItem />
  </TodoList>
</TodoContainer>
```

<Notes>

Here's what more or less the component structure looks like
There's a TodoContainer, which is connected to the redux store
It renders a TodoList component, which renders some todo items

also a Username input and conditionally an InboxZero message, both of which are also connected to redux
We'll see why that's important for testing in a bit

</Notes>

---

# TodoList Props

```jsx
const TODO_LIST = [{id: 1, title: 'Get Milk'}, ...];
const props = {
  todoList: TODO_LIST,
  onTodoChange: jest.fn(),
  onDelete: jest.fn()
};
```

<Notes>

As a note, for all these tests we'll use this same set of props
in React a component takes a set of props to render itself
React functions are functions that take props and return HTML
So if todo list has two items, then the component will render two input boxes
Also, jest.fn is how you make a spy in jest.
A spy is a function that we can make return something if we want
But either way can check if its been called in a test.

TodoList interacts with the redux store, so clicking a button won't directly do anything except call one of these functions
That means...

</Notes>

---

# Most React Tests test two things:

1. Given **props**, does it render the right **elements**?
1. Given an **event**, does it **call** the right functions?

---

# Decisions, decisions...

Shallow vs Full Render

Tradtional Expectations vs Snapshots

<Notes>

There are two decisions you have to make about any component test
Shallow renders one component, full renders children
Traditional expectations are how you normally write tests
Expect x to have prop y
Snapshots take a snapshot of the dom, and fail if it changes
Let's go through them

</Notes>

---

# Shallow Render

```jsx
<TodoList>
  <Connected(UsernameInput) />
  <TodoItem />
  <TodoItem />
  Done Items
  <TodoItem />
  <TodoItem />
</TodoList>
```

<Notes>

In a shallow test, you only render one level deep. So if I shallow-rendered the TodoList component, it renders
its children, which are TodoItem components. But it doesn't go and render those children,
so it doesn't go all the way to the level of buttons and inputs
Makes for good unit testing - TodoList doesn't know how its children render themselves, so arguably its test shouldn't either

</Notes>

---

# Enzyme Shallow

```jsx
import { shallow } from "enzyme";
it("renders all todo items", () => {
  const wrapper = shallow(<TodoList {...props} />);
  expect(wrapper.find("TodoItem")).toHaveLength(TODO_LIST.length);
});
```

<Notes>

Here's how you set up a shallow render in enzyme.
Import shallow, and render the component with some props
Then you have a wrapper that you can traverse and assert on
Check that it has one TodoItem for each list item.

</Notes>

---

```jsx
it("passes props down", () => {
  expect(
    wrapper
      .find("TodoItem")
      .first()
      .prop("todo")
  ).toEqual(TODO_LIST[0]);
});
```

<Notes>

Since we're not rendering the actual inputs, we can't check they they have the right data
All we can do is check that we're passing the right data to the right component.
Then can write another test that checks that, given some todo data, the TodoItem component show it in an input
So nice and isolated

</Notes>

---

# Shallow Downside: Refactoring

<Notes>

I like this approach
One big downside is refactoring - change to the code, but not what it does
a good react dev looks for opportunities to refactor a chunk of html into a component
Shallow makes that harder
look at an example:

</Notes>

---

```jsx
<TodoList>
  Things to do:
  <TodoItem todo={todos[0]}>
  <TodoItem todo={todos[1]}>
  Done:
  <TodoItem todo={todos[2]}>
  <TodoItem todo={todos[3]}>
</TodoList>
```

<Notes>

So here's how this looks now: there's some code that seperates out done todos and puts them under a header
But maybe we want to add a wrapper component, TodoWrapper, that gets a list of either to-do or done items, and renders them
with the right header.
That would look like:

</Notes>

---

# Refactored

```jsx
<TodoList>
  <TodoWrapper done={false} todos={[todos[0], todos[1]]} />
  <TodoWrapper done={true} todos={[todos[2], todos[3]]} />
</TodoList>
```

<Notes>

Seems like a good refactor, but now all the tests are broken, because TodoList isn't rendering TodoItems anymore
So even though from a user perspective the UX is exactly the same, we have to totally rewrite our tests
This might make you decide not to make the right refactor, which is a bummer

</Notes>

---

# react-test-render Shallow

```jsx
import { createRenderer } from "react-test-renderer/shallow";
const renderer = createRenderer();
renderer.render(<TodoList {...props} />);
const component = renderer.getRenderOutput();
```

<Notes>

also lets you shallow render, but you can't do much except snapshot the
result, which we'll see later.
So less interesting

</Notes>

---

# React Testing Library

<Img src={kentShallow} />

<Notes>

Kent Dodds isn't a fan of shallow testing, so... yeah, no shallow in his library.

</Notes>

---

# Mount / Full Render

<Notes>

Alternative is reneering the whole tree - a component, and all its children, down to the DOM
Called mount in enzyme, but you can think of it as a full instead of shallow render

</Notes>

---

```html
<div class="TodoList">
  <div>
    <h2>Todo List for:</h2>
    <input class="UsernameInput" />
  </div>
  <hr />
  <div class="TodoItem">
    <input placeholder="Enter a todo item" value="Learn Enzyme" />
    <button>Done</button>
    <button>X</button>
  </div>
  ...
</div>
```

<Notes>

Here's what the TodoList looks like from a mount test.
You can see the TodoList, Username input, and individual TodoItems, which are all components
But they're rendered down to divs and buttons, instead of components
So you can do things like trigger a click on a button that should effect a parent's state

</Notes>

---

# Enymze mount

```jsx
import { mount } from "enzyme";

const wrapper = mount(<TodoList {...props} />);
```

<Notes>

Easy as shallow, just different import

</Notes>

---

```jsx
it("changes todo items", () => {
  wrapper
    .find("input")
    .find({ value: TODO_LIST[0].title })
    .simulate("change", { target: { value: "New Title" } });

  expect(props.onTodoChange).toHaveBeenCalledWith({
    ...TODO_LIST[0],
    title: "New Title"
  });
});
```

<Notes>

And now we can write a test that simulates typing a value into an input, and make sure that makes its waya
all the way back to the onChange callback that would trigger an API call.
This is great - this test is resiliant to the TodoWrapper refactor that adds an extra layer of components in between the list
and the items.

You may be thinking, why did I waste my time learning about shallow?
Well the first thing is, if you went into the TodoInput and changed the inputs to textareas,
then your TodoList test would fail, even though the change was in its child

But there's another problem...

</Notes>

---

# The test fails üòû

<Img src={mountFail} alt="Mount error message" />

<Notes>

This doesn't actually work. The error message says the problem is with UsernameInput, which is weird,
because this test doesn't have anything to do with that.

</Notes>

---

# Redux Troubles

```jsx
<TodoList>
  <Connected(UsernameInput) /> <-- the problem
  <TodoItem />
  <TodoItem />
```

<Notes>

If you've used redux before, you may already know what's going on here
I don't want to get too into redux here, but the upshot is the username input component is a
connect redux component, that will only work if there's a Provider in the component tree
So even though the redux thing is on a child, and we don't care about the child in this test,
we need to set up the test in a way that will make the component work.

</Notes>

---

# No Connected Child:

```jsx
import { mount } from "enzyme";

const wrapper = mount(<TodoList {...props} />);
```

<Notes>

So you can only use this code to mount a component if it doesn't happen to have a redux
child.

</Notes>

---

```jsx
import { mount } from "enzyme";
import { Provider } from "react-redux";
import configureMockStore from "redux-mock-store";
import thunk from "redux-thunk";
import defaultStore from "../redux/defaultStore";
const middleware = [thunk];
const mockStore = configureMockStore(middleware);

const wrapper = mount(
  <Provider store={store}>
    <TodoList {...props} />
  </Provider>
);
```

<Notes>

If any child (or grandchild) is connected though, you have to do, uh, some setup

</Notes>

---

<BgImage
  src="https://media.giphy.com/media/eBCnpuRGBhQGY/giphy.gif"
  backgroundSize="cover"
/>

<Notes>

Not ideal. And the problem isn't just react - you never know what some child component will do, that's the point of unit testing.

I was once using a fancy text editor library. We wanted to test a simple change event, and we had to dig into the source code to figure out how to do that.

</Notes>

---

# Mocks to the rescue!

```jsx
jest.mock("../user/UsernameInput", () => () => (
  <div className="UsernameInput" />
));

const wrapper = mount(<TodoList {...props} />);
```

<Notes>

Of course there's a standard solution to dependencies, which
is mocking. We can mock out the child component with a
stub that's easier to work with, and go on with our lives.

This works, but then you have all the problems of mocks -
you have to know what to mock, and have to keep those mocks
up-to-date with the real implementation.

Still, for something between a shallow render (where everything is mocked) and a full render (where nothing is), this can be a good choice.

</Notes>

---

# React Testing Library

```jsx
import { render, fireEvent } from "@testing-library/react";
...
const input = result.getByDisplayValue('Get Milk');
fireEvent.change(input, {
  target: { value: "New Title" }
});

expect(props.onTodoChange).toHaveBeenCalledWith({
...
```

<Notes>

So given that you're down with mount tests, then RTL is really nice

It pushes you towards writing tests from a user perspective.

So instead of saying, "find an input with the right css class, make sure it has the right value prop, then simulate an event from it", you can just say, 'yo, find the input with the right text, and fire a change event on it".

If you change the structure of the components, or switch from input to text area, this test will keep passing

And there are lots of nice selectors, you can query by label, or placeholder, or a special test data id. In the end it's still the same data in, DOM out tests as enzyme, but with a different twist.

There's a whole ecosystem around this libary that's cropped up - including Cypress integration - so if that user-centered testing appeals to you, then dig in.

</Notes>

---

# react-test-renderer

<Notes>

Finally there's react test renderer, which takes the opposite approach.
Its API is even lower level than Enzymes. Enzyme or RTL is almost always a better choice, but
this had a moment eariler this year while everyone else was catching up with some 16.8
changes with react hooks, so you may see it in the wild.

</Notes>

---

```jsx
import renderer from "react-test-renderer";

it("changes todo items", () => {
  ...

  const input = component.findByProps({
    value: 'Get Milk'
  });
  input.props.onChange({ target: { value: "New Title" } });

  expect(props.onTodoChange).toHaveBeenCalledWith({
  ...
```

<Notes>

So more like enzyme, without some of the user-centric helpers. But a totally
servicable library, and its nice that its by the react team,
so it'll always support the latest features.
There are also only a few matchers, so for simple tests there's less to learn.

</Notes>

---

# Snapshot Testing

<Notes>

So far we've seen a few different ways to write standard tests.
Jest has a second method for writing tests that works with all these libraries
It's called snapshot testing, and it can be pretty handy in specific use cases

In a normal test, you come up with the specific things that should be true
In a snapshot test you take a snapshot of the state of the whole dom
Or any other JS object actually
This gets saved to a file, and then the next time you run the tests, it checks if that
output has changed at all. If it does, the test fails

</Notes>

---

<Img src={snapshot} />

<Notes>

Here's a failing snaphot, from an enzyme shallow test in this case.
I broke the conditional logic about only showing the inbox zero message when there's nothing to do.
The snapshot failed, and the diff shows the problem is this component wasn't in the snapshot last
time, but is now.

This is pretty sweet. I didn't have to write any specific test for this functionality - I just took a
snapshot, and it handled that test for me.

</Notes>

---

# Can I Stop Writing Tests Now?

<Notes>

So... does that mean you don't need real tests anymore? Just snapshot everything and call it a day?

</Notes>

---

<BgImage src="https://media.giphy.com/media/BiRHhbCpFK8k8/giphy.gif" />

<Notes>

Yeah, that doesn't go as well as you think it will

</Notes>

---

<Img src={snapshotBad} />

<Notes>

Unfortunatly snapshot failures often look like this. Can you see the problem?
Yeah, I just added a little div around some components, and everything goes red.
You can look closely and figure it out, but I've found that in practice, devs
get tired of that, and just re-record snapshots without looking at them.
Me included!
So I'd reccomend limiting the scope of snapshots, so you know that if one fails,
it might be real. Shallow is a good way to do that.

</Notes>

---

# Everybody's doing it

```jsx
// Enyzyme
expect(wrapper.debug()).toMatchSnapshot();
// React Testing Library
expect(result).toMatchSnapshot();
// react-test-renderer
expect(testRenderer.toJSON()).toMatchSnapshot();
// react-test-renderer shallow
expect(testRenderer.getRenderOutput()).toMatchSnapshot();
```

<Notes>

If you want to use snapshots,
all these libraries have a way of outputting a JSON representation of the DOM,
which can be easily snapshotted. So whatever library you pick, you can use this.

But to keep snapshots small, one thing to do would be to use RTL for normal tests,
and RTR shallow for snapshots. YMMV.

</Notes>

---

- Unit Testing
  - Jest
    - Enzyme Shallow
    - Enzyme Mount
    - Snapshot Testing (w/ Test Renderer): https://reactjs.org/docs/test-renderer.html)
    - React Testing Library
    - Hooks (React.useEffect + spy)
    - --coverage
